<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原型</title>
</head>
<body>
    <script>
        // 继承对于JS来说就是父类拥有的属性和原型方法、静态方法等，子类也要拥有。
// 父亲
function Parent(num) {
    this.num = num;
}
Parent.prototype.type = 'human';
Parent.prototype.sayNum =function(){
    console.log('num:' + this.num);
}
Parent.staticType = 'staticHuman';
Parent.sayHello = function () {
    console.log('Hello')
}

// 儿子
function Child(num,age) {
    // 相当于super
    // 子类构造器里调用父类构造器，继承父类的属性。
    Parent.call(this,num);
    this.age = age;
}
Child.prototype.sayAge = function () {
    console.log('age:' + this.age);
}

       
    </script>


    <script>
        // 寄生组合式继承
// 子类构造函数的prototype的__proto__指向父类构造器的prototype，继承父类的方法。
Child.prototype.__proto__ = Parent.prototype;
// Child.prototype = new Parent();

// Child.prototype.__proto__ = Parent.prototype;
// 子类构造函数的__proto__指向父类构造器，继承父类的静态方法
Child.__proto__ = Parent;
// Child.prototype.constructor = Child;
const parent = new Parent(1);
console.log(parent.type);
console.log(Parent.staticType);
parent.sayNum();
Parent.sayHello();

    console.log('-----------------------')

const child = new Child(2,18);
console.log(child.type);
console.log(Child.staticType);
child.sayNum();
// child.sayAge();
Child.sayHello();

console.log(Parent.prototype.constructor)
console.log(Child.prototype.constructor)

    </script>
<!-- 
    <script>
        function _inherits(Child, Parent) {
            // __proto__
            Child.prototype.__proto__ = Parent.prototype;
            // Object.setPrototypeOf(Child.prototype, Parent.prototype);
            Child.prototype.constructor = Child;
            // __proto__
            Child.__proto__ = Parent;
            // Object.setPrototypeOf(Child, Parent);
        }
    </script> -->

</body>
</html>